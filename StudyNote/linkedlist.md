# 動態記憶體管理：鏈結串列 (Linked List) 的架構與實作分析

本篇筆記深入探討非連續記憶體配置下的線性結構——鏈結串列，並分析其在不同操作情境下的演算法效率與指標操作細節。

---

## 1. 鏈結結構核心機制 (Core Mechanics)

不同於 Array 的連續空間配置，Linked List 透過節點 (Node) 散佈於記憶體中。
* **節點組成**：包含數據域 (Data Field) 與 指標域 (Pointer Field)。指標域儲存下一個節點的記憶體位址，形成邏輯上的連續性。
* **頭指標 (Head)**：作為存取入口，其安全性至關重要。一旦 Head 遺失或指向錯誤，將導致整條串列發生 **Memory Leak**。



---

## 2. 結構變體與選擇策略 (Variations)

| 類型 | 技術特點 | 應用場景 |
| :--- | :--- | :--- |
| **單向鏈結 (Singly)** | 單一 Next 指標，空間開銷最小。 | 簡單的堆疊或隊列實作。 |
| **雙向鏈結 (Doubly)** | 具備 Prev 與 Next，支援 $O(1)$ 的雙向查找。 | 需要頻繁在已知節點前後插入/刪除時（如 `std::list`）。 |
| **環狀鏈結 (Circular)** | 尾節點指向頭節點，無終止符號。 | 適合輪詢調度 (Round-robin) 或循環緩衝。 |

---

## 3. 基本操作演算法與指標相依性

在鏈結串列中，插入與刪除的物理時間雖為 $O(1)$，但尋找目標位置的過程通常需 $O(n)$。

### 關鍵操作分析
1. **插入 (Insertion)**：必須先調整「新節點的 Next」，再修改「前驅節點的 Next」。順序顛倒會導致後端節點斷裂。
2. **刪除 (Deletion)**：需精確定位前驅節點 (Predecessor)，將其跳過目標節點指向下一個地址，並手動釋放 (Free/Delete) 記憶體。



---

## 4. 實作深度探討：選擇排序 (Selection Sort)

在 HW3 的實作中，針對 Linked List 的排序存在兩種策略權衡：

* **策略 A：數值交換 (Value Swapping)**
    * **優點**：指標結構不動，邏輯單純。
    * **缺點**：若資料項 (Data Item) 體積龐大（例如結構體），頻繁搬移資料會造成極大的效能損失。
* **策略 B：指標交換 (Pointer Manipulation)**
    * **優點**：僅更動 4-8 bytes 的指標，對於大數據處理效率極高。
    * **細節**：強烈建議使用 **Dummy Node (虛擬頭節點)**，可統一處理「首項交換」與「中間交換」的邊界條件。



---

## 5. 陣列與鏈結串列之效能對比 (Asymptotic Analysis)

| 維度 | 陣列 (Array) | 鏈結串列 (Linked List) |
| :--- | :--- | :--- |
| **隨機存取** | $O(1)$ | $O(n)$ |
| **插入/刪除** | $O(n)$ (需搬移) | $O(1)$ (指標已知時) |
| **記憶體利用** | 預分配，可能產生碎片。 | 動態配置，但每個節點有額外指標開銷。 |
| **Cache 友善度** | 高 (具備空間局部性) | 低 (節點位置分散) |

---
Gemini AI prompt:利用linkedlist檔案整理一份詳細筆記
