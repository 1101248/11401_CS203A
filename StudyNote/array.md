# 記憶體連續配置分析：靜態與動態陣列 (Static & Dynamic Arrays)

本筆記探討資料結構中最基礎的線性形式——陣列。重點分析其在實體記憶體中的佈局特性，以及在不同維度與配置模式下的效能表現。

---

## 1. 核心特性：連續性與隨機存取

陣列是一組存儲在**連續記憶體空間**中的同質元素集合。
* **隨機存取 (Random Access)**：由於記憶體連續，可透過公式 `Address = Base + Index * Size` 在 $O(1)$ 時間內精確定位元素。
* **空間局部性 (Spatial Locality)**：由於元素相鄰，對 CPU Cache 非常友善，執行效率通常高於非連續結構。



---

## 2. 靜態陣列與多維空間佈局

靜態陣列的大小在編譯時期 (Compile-time) 決定，空間通常配置於 **Stack (堆疊)** 區段。

### 多維陣列的實體映射
雖然邏輯上存在二維或三維結構，但在實體記憶體中皆為一維排列：
* **Row-Major Order (列優先)**：C/C++ 採用的方式，先填滿一列再換下一列。
* **存取效率**：遍歷多維陣列時，依序存取相鄰元素能最大化 Cache Hit Rate。



---

## 3. 動態陣列與記憶體生命週期管理

動態陣列允許在執行時期 (Runtime) 決定大小，空間配置於 **Heap (堆積)** 區段。

### 資源管理核心 (C/C++ 實作)
1. **配置與調整**：使用 `malloc` 或 `new` 分配空間。當容量不足時，需透過 `realloc` 進行擴增。
2. **擴容機制**：通常採「倍增策略」。擴容涉及「申請新空間 -> 搬移舊資料 -> 釋放原空間」，這是一個 $O(n)$ 的重負荷操作。
3. **記憶體洩漏 (Memory Leak)**：手動配置的空間必須對應 `free` 或 `delete`。在網管實習處理大量封包緩衝時，未釋放的陣列將導致系統崩潰。



---

## 4. 演算法複雜度分析 (Complexity Analysis)

| 操作項目 | 時間複雜度 | 說明 |
| :--- | :--- | :--- |
| **讀取/更新 (Access)** | $O(1)$ | 透過索引直接定位地址。 |
| **插入/刪除 (Insert/Delete)** | $O(n)$ | 需移動插入點後的所有元素以維持連續性。 |
| **線性搜尋 (Linear Search)** | $O(n)$ | 最壞情況需走訪全陣列。 |
| **二元搜尋 (Binary Search)** | $O(\log n)$ | 僅適用於**已排序**的陣列。 |

---

## 5. 實務應用與容器選擇

* **std::array (C++11)**：封裝靜態陣列，提供邊界檢查與迭代器支援，較傳統 C-style array 更安全。
* **std::vector**：最常用的動態陣列實作。其自動擴容機制在靈活性與效能間取得了平衡。

---
Gemini AI prompt:利用array檔案整理一份詳細筆記
