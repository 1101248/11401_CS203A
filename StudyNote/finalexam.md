# 📚 資料結構期末考：核心章節終極筆記

## 一、 雜湊 (Hashing)
雜湊透過雜湊函式 (Hash Function) 將鍵值 (Key) 轉換為陣列索引，目標是達到平均 **$O(1)$** 的搜尋、插入與刪除效能。

### 1. 核心組成
* **雜湊表 (Hash Table)**：儲存資料的陣列結構。
* **雜湊函式 ($h(k)$)**：具備確定性、均勻分佈、高效計算。
* **載重因子 (Load Factor, $\alpha$)**：$\alpha = n / m$。
    * $n$: 元素數量
    * $m$: 表的大小（Bucket 數量）

### 2. 衝突處理 (Collision Handling)
當不同 Key 對應到同一 Index 時產生衝突：

| 處理方法 | 機制說明 | 優缺點分析 |
| :--- | :--- | :--- |
| **鏈結法 (Chaining)** | 每個槽位接一個 Linked List。 | 簡單、不限 $\alpha > 1$，但需額外指標空間。 |
| **線性探測 (Linear)** | 順序尋找下一個空位：$(h(k)+i) \pmod m$。 | **主要群集 (Primary Clustering)** 問題嚴重。 |
| **二次探測 (Quadratic)** | 間隔平方增加：$(h(k)+i^2) \pmod m$。 | 減少主要群集，但有次要群集 (Secondary Clustering)。 |
| **雙重雜湊 (Double)** | 用第二個函式決定步長：$(h_1(k)+i \cdot h_2(k)) \pmod m$。 | 分佈最均勻，效能最佳。 |



---

## 二、 樹 (Trees) 與 堆積 (Heaps)

### 1. 結構分類
* **完全二元樹 (Complete Binary Tree)**：除了最後一層外皆填滿，且節點由左至右靠攏。
* **二元搜尋樹 (BST)**：左子樹 < 根節點 < 右子樹。
* **堆積 (Heap)**：
    * **Max Heap**: 父節點 $\ge$ 子節點。
    * **Min Heap**: 父節點 $\le$ 子節點。

### 2. 表達式樹 (Expression Tree)
* **遍歷**：使用「中序遍歷 (Inorder)」輸出數學算式。
* **計算**：括號內子樹（底層）優先計算，最後才是根節點。



---

## 三、 圖形 (Graphs) $G(V, E)$

### 1. 基本屬性
* **方向性**：無向圖 (Undirected) vs 有向圖 (Directed)。
* **權重 (Weight)**：邊上的數值（成本/距離）。
* **連通性 (Connected)**：任兩點皆有路徑相通。

### 2. 圖形走訪 (Traversal)
* **廣度優先搜尋 (BFS)**：
    * **機制**：逐層 (Layer by Layer) 探索。
    * **工具**：使用 **佇列 (Queue)**。
    * **實例**：`0 -> 1 -> 2 -> 3 -> 4 -> 6 -> 7 -> 5` (依層次)。
* **深度優先搜尋 (DFS)**：
    * **機制**：一條路走到底。
    * **工具**：使用 **堆疊 (Stack)** 或遞迴。



---

## 四、 考前快速對照表：時間複雜度 (Big-O)

| 資料結構 / 操作 | 搜尋 (Search) | 插入 (Insert) | 刪除 (Delete) | 備註 |
| :--- | :--- | :--- | :--- | :--- |
| **雜湊表 (平均)** | $O(1)$ | $O(1)$ | $O(1)$ | 依賴好的雜湊函式與 $\alpha$ 控制。 |
| **二元搜尋樹 (BST)** | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | 最差情況 (傾斜) 為 $O(n)$。 |
| **堆積 (Heap)** | $O(n)$ | $O(\log n)$ | $O(\log n)$ | 找 Max/Min 僅需 $O(1)$。 |
| **圖 (BFS/DFS)** | $O(V+E)$ | - | - | 走訪所有頂點 $V$ 與邊 $E$。 |

Gemini AI prompt:利用先前所有檔案與作業整理一份期末考前的複習檔案
