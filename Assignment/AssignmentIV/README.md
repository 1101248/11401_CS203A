# CS203A Assignment IV
---

---

## 演算法設計

### 1. 數值型資料：中平方法 (Mid-Square Hashing)
針對連續性整數鍵值 (Integer Keys)，本設計捨棄單純的取模運算，採用中平方法以破壞資料的線性規律。
* **運算流程**：
    1.  將原始鍵值進行平方運算 (Key^2)。
    2.  提取平方值中間段的數字位元（捨棄頭尾，減少高低位元的直接影響）。
    3.  將提取結果對表長 m 取模。
* **設計動機**：傳統 Division 方法在處理連續數列時會產生嚴重的「集簇 (Clustering)」現象。中平方法能透過平方擴張將微小的輸入差異放大，提升索引的離散程度。

### 2. 字串型資料：字元權重累加 (ASCII-Sum Hashing)
針對字串鍵值，採用遍歷累加機制。
* **運算流程**：\text{Hash} = (\sum \text{ASCII}(c_i)) \pmod m
* **設計動機**：確保字串中的每個字元都參與運算，避免僅取首字導致的嚴重碰撞（如 "cat", "car", "cow" 的首字衝突）。

---

## 數據

### 整數測試 (Dataset: 21-30, 51-60)
| Table Size ($m$) | 演算法 | 分布觀察 (Observations) |
| :--- | :--- | :--- |
| **10** | Division | 產生明顯的線性循環，21-30 與 51-60 的索引完全重疊。 |
| **11 (Prime)** | Mid-Square | 索引分布趨於隨機，連續鍵值間的相關性顯著降低。 |
| **37 (Prime)** | Mid-Square | 展現極佳的擴散性 (Diffusion)，在 m 增大時，碰撞率幾乎歸零。 |

### 字串測試 (Dataset: cat, dog, bat, etc.)
* **觀察結果**：在 m=10 時，由於 ASCII 累加值的區間重疊，仍存在結構性碰撞。然而在 $m=37$ 時，較大的餘數空間有效緩解了簡單累加法的不足。

---

## 技術

1.  **模數選擇的影響**：實驗證明，選用 **質數 (Prime Number)** 作為 m 值，能顯著提升雜湊分布的均勻度。這是因為質數與輸入值產生公因數的機率較低，能減少週期性的碰撞。
2.  **演算法強健性**：Mid-Square 方法雖計算量略高於 Division，但在處理「具規律性」的輸入時，展現了更強的抗碰撞能力。
3.  **字串雜湊限制**：單純的 ASCII 累加法忽略了字元的「位置資訊」（如 "abc" 與 "cba" 的 Hash 相同）。若要進一步優化，應引入權重因子（如 Polynomial Rolling Hash）。

---

## 個人總結與反思

透過本次 Assignment IV 的實作，我對雜湊表從「資料存取工具」轉變為「效能平衡藝術」有了深刻體會。

**關於碰撞規避：**
起初我認為增加 Table Size (m) 是解決碰撞的唯一手段，但實驗結果反駁了這一點。若雜湊函數本身具備線性規律（如 Division），即便 $m$ 增大，資料依然會呈現結構性的叢聚。真正關鍵在於雜湊函數的 **「混亂特性 (Entropy)」**。

**實務應用思考：**
在未來處理網管實習中的 IP 過濾表 (Filtering Table) 或封包快取時，雜湊函數的穩定性直接影響到系統的吞吐量 (Throughput)。我學到不能僅追求最簡單的實作，必須根據資料特性（如 IP 的連續性）選擇合適的非線性轉換（如 Mid-Square），並嚴格選用質數作為空間大小，這才是身為資工系學生應具備的實務嚴謹度。

---

## 建置與執行

```bash
# 同時建置 C 與 C++ 版本
make all

# 執行整數雜湊測試
./C/hash_function
./CXX/hash_function_cpp
